{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils.ts"],
  "sourcesContent": ["import { isFunction, uuid } from './utils';\n\ntype MessageType = 'add' | 'remove' | 'clear' | 'invoke';\ninterface Message {\n  type: MessageType;\n  name?: string;\n  code?: string;\n  id?: string;\n  params?: any;\n}\nexport class FuncWork {\n  private worker: Worker;\n  private scriptUrl: string;\n  private methodSet: Set<string>;\n\n  private genCodeString(method: Function): string {\n    const funcCode = Function.prototype.toString.call(method);\n    return `(function(){return ${funcCode}})()`;\n  }\n\n  private updateWorker(message: Message) {\n    this.worker.postMessage(JSON.stringify(message));\n  }\n\n  private terminate() {\n    URL.revokeObjectURL(this.scriptUrl);\n    this.scriptUrl = '';\n    if (this.worker) {\n      this.worker.terminate();\n    }\n  }\n\n  constructor(options?: WorkerOptions) {\n    if (!window) {\n      throw new Error('Detected not in browser environment.');\n    }\n    if (!window.Worker) {\n      throw new Error('Web Worker is not supported in the environment.');\n    }\n    if (!window.URL && !URL.createObjectURL) {\n      throw new Error('URL API is not supported in the environment.');\n    }\n    if (!window.Promise) {\n      throw new Error('Promise Feature is not supported in the environment.');\n    }\n\n    this.methodSet = new Set();\n    // @ts-ignore\n    this.scriptUrl = URL.createObjectURL(new Blob([__WORKER_SCRIPT__]));\n    this.worker = new Worker(this.scriptUrl, options);\n  }\n\n  add(...methods: Function[]): this {\n    methods.forEach((method, index) => {\n      if (!isFunction(method)) {\n        console.warn(`Registration failed, methods[${index}] is not a Function type.`);\n        return;\n      }\n      const name = method.name;\n      if (!name || name.trim() === '') {\n        console.warn(`Registration failed, methods[${index}] is a anonymous function.`);\n        return;\n      }\n      if (this.methodSet.has(name)) {\n        console.warn(`Registration failed, methods[${index}] is already registered.`);\n        return;\n      }\n      this.methodSet.add(name);\n      this.updateWorker({\n        name,\n        type: 'add',\n        code: this.genCodeString(method)\n      });\n    });\n    return this;\n  }\n\n  remove(name: string | Function) {\n    if (isFunction(name)) {\n      name = name.name;\n    }\n    if (!this.methodSet.has(name)) return;\n    this.methodSet.delete(name);\n    this.updateWorker({\n      type: 'remove',\n      name\n    });\n  }\n\n  clear() {\n    this.methodSet.clear();\n    this.updateWorker({\n      type: 'clear'\n    });\n  }\n\n  list(): String {\n    const result: string[] = [];\n    this.methodSet.forEach((k) => {\n      result.push(k);\n    });\n    return result.join(' | ');\n  }\n\n  invoke(name: string | Function, params?: any[]): Promise<any> | never {\n    if (isFunction(name)) {\n      name = name.name;\n    }\n    if (!this.methodSet.has(name)) {\n      throw new Error(`${name} is not defined in Funcwork.`);\n    }\n\n    const uid = uuid();\n\n    return new Promise((resolve, reject) => {\n      const onResolve = (ev: MessageEvent<string>) => {\n        try {\n          const { id, data } = JSON.parse(ev.data);\n          if (id === uid) {\n            resolve(data)\n          }\n        } catch (e) {\n          reject(e);\n        }\n        this.worker.removeEventListener('message', onResolve);\n        this.worker.removeEventListener('error', onReject);\n      };\n\n      const onReject = (err: ErrorEvent) => {\n        this.worker.removeEventListener('message', onResolve);\n        this.worker.removeEventListener('error', onReject);\n        reject(err);\n      };\n\n      // refactor: register event listener once\n      this.worker.addEventListener('message', onResolve);\n      this.worker.addEventListener('error', onReject);\n\n      this.updateWorker({\n        type: 'invoke',\n        name: (name as string),\n        params: Array.isArray(params) ? params : [params],\n        id: uid\n      });\n    });\n  }\n\n  destroy() {\n    this.terminate();\n    this.clear();\n  }\n}", "export const isFunction = (val: any): val is Function => typeof val === 'function';\n\nexport const uuid = () => `${Date.now}Math.random().toString().slice(10, 15)`;"],
  "mappings": "6GAAA,+BCAO,GAAM,GAAa,AAAC,GAA8B,MAAO,IAAQ,WAE3D,EAAO,IAAM,GAAG,KAAK,4CDQ3B,WAAe,CAKZ,cAAc,EAA0B,CAE9C,MAAO,sBADU,SAAS,UAAU,SAAS,KAAK,SAI5C,aAAa,EAAkB,CACrC,KAAK,OAAO,YAAY,KAAK,UAAU,IAGjC,WAAY,CAClB,IAAI,gBAAgB,KAAK,WACzB,KAAK,UAAY,GACb,KAAK,QACP,KAAK,OAAO,YAIhB,YAAY,EAAyB,CACnC,GAAI,CAAC,OACH,KAAM,IAAI,OAAM,wCAElB,GAAI,CAAC,OAAO,OACV,KAAM,IAAI,OAAM,mDAElB,GAAI,CAAC,OAAO,KAAO,CAAC,IAAI,gBACtB,KAAM,IAAI,OAAM,gDAElB,GAAI,CAAC,OAAO,QACV,KAAM,IAAI,OAAM,wDAGlB,KAAK,UAAY,GAAI,KAErB,KAAK,UAAY,IAAI,gBAAgB,GAAI,MAAK,CAAC;AAAA,KAC/C,KAAK,OAAS,GAAI,QAAO,KAAK,UAAW,GAG3C,OAAO,EAA2B,CAChC,SAAQ,QAAQ,CAAC,EAAQ,IAAU,CACjC,GAAI,CAAC,EAAW,GAAS,CACvB,QAAQ,KAAK,gCAAgC,8BAC7C,OAEF,GAAM,GAAO,EAAO,KACpB,GAAI,CAAC,GAAQ,EAAK,SAAW,GAAI,CAC/B,QAAQ,KAAK,gCAAgC,+BAC7C,OAEF,GAAI,KAAK,UAAU,IAAI,GAAO,CAC5B,QAAQ,KAAK,gCAAgC,6BAC7C,OAEF,KAAK,UAAU,IAAI,GACnB,KAAK,aAAa,CAChB,OACA,KAAM,MACN,KAAM,KAAK,cAAc,OAGtB,KAGT,OAAO,EAAyB,CAI9B,AAHI,EAAW,IACb,GAAO,EAAK,MAEV,EAAC,KAAK,UAAU,IAAI,IACxB,MAAK,UAAU,OAAO,GACtB,KAAK,aAAa,CAChB,KAAM,SACN,UAIJ,OAAQ,CACN,KAAK,UAAU,QACf,KAAK,aAAa,CAChB,KAAM,UAIV,MAAe,CACb,GAAM,GAAmB,GACzB,YAAK,UAAU,QAAQ,AAAC,GAAM,CAC5B,EAAO,KAAK,KAEP,EAAO,KAAK,OAGrB,OAAO,EAAyB,EAAsC,CAIpE,GAHI,EAAW,IACb,GAAO,EAAK,MAEV,CAAC,KAAK,UAAU,IAAI,GACtB,KAAM,IAAI,OAAM,GAAG,iCAGrB,GAAM,GAAM,IAEZ,MAAO,IAAI,SAAQ,CAAC,EAAS,IAAW,CACtC,GAAM,GAAY,AAAC,GAA6B,CAC9C,GAAI,CACF,GAAM,CAAE,KAAI,QAAS,KAAK,MAAM,EAAG,MACnC,AAAI,IAAO,GACT,EAAQ,SAEH,EAAP,CACA,EAAO,GAET,KAAK,OAAO,oBAAoB,UAAW,GAC3C,KAAK,OAAO,oBAAoB,QAAS,IAGrC,EAAW,AAAC,GAAoB,CACpC,KAAK,OAAO,oBAAoB,UAAW,GAC3C,KAAK,OAAO,oBAAoB,QAAS,GACzC,EAAO,IAIT,KAAK,OAAO,iBAAiB,UAAW,GACxC,KAAK,OAAO,iBAAiB,QAAS,GAEtC,KAAK,aAAa,CAChB,KAAM,SACN,KAAO,EACP,OAAQ,MAAM,QAAQ,GAAU,EAAS,CAAC,GAC1C,GAAI,MAKV,SAAU,CACR,KAAK,YACL,KAAK",
  "names": []
}
